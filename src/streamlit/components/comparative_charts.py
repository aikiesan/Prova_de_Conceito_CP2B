"""
Gr√°ficos Comparativos Avan√ßados para An√°lise de Res√≠duos - CP2B
Visualiza√ß√µes especializadas para comparar diferentes aspectos dos res√≠duos de biog√°s
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np
from typing import Dict, List, Optional, Any
import logging

logger = logging.getLogger(__name__)

def render_residue_treemap(df: pd.DataFrame) -> None:
    """Renderiza treemap hier√°rquico mostrando propor√ß√£o dos res√≠duos"""
    
    st.subheader("üå≥ Visualiza√ß√£o Hier√°rquica dos Res√≠duos")
    
    if df.empty:
        st.warning("Nenhum dado dispon√≠vel")
        return
    
    # Preparar dados para treemap
    treemap_data = []
    
    # Definir mapeamento de res√≠duos por categoria
    residue_categories = {
        'Agr√≠cola': {
            'biogas_cana_nm_ano': 'üåæ Cana',
            'biogas_soja_nm_ano': 'üå± Soja', 
            'biogas_milho_nm_ano': 'üåΩ Milho',
            'biogas_cafe_nm_ano': '‚òï Caf√©',
            'biogas_citros_nm_ano': 'üçä Citros'
        },
        'Pecu√°ria': {
            'biogas_bovinos_nm_ano': 'üêÑ Bovinos',
            'biogas_suino_nm_ano': 'üê∑ Su√≠nos',
            'biogas_aves_nm_ano': 'üêî Aves',
            'biogas_piscicultura_nm_ano': 'üêü Piscicultura'
        },
        'Urbano': {
            'rsu_potencial_nm_habitante_ano': 'üóëÔ∏è RSU',
            'rpo_potencial_nm_habitante_ano': 'üåø RPO'
        }
    }
    
    # Calcular valores para cada res√≠duo
    for category, residues in residue_categories.items():
        for residue_key, residue_label in residues.items():
            if residue_key in df.columns:
                total_value = df[residue_key].sum()
                if total_value > 0:
                    treemap_data.append({
                        'Category': category,
                        'Residue': residue_label,
                        'Value': total_value,
                        'Full_Label': f"{category} - {residue_label}"
                    })
    
    if not treemap_data:
        st.warning("Nenhum dado de res√≠duos encontrado")
        return
    
    treemap_df = pd.DataFrame(treemap_data)
    
    # Criar treemap
    fig = px.treemap(
        treemap_df,
        path=[px.Constant("Biog√°s SP"), 'Category', 'Residue'],
        values='Value',
        title="Distribui√ß√£o Proporcional do Potencial de Biog√°s por Res√≠duo",
        color='Value',
        color_continuous_scale='Viridis',
        labels={'Value': 'Potencial (Nm¬≥/ano)'}
    )
    
    fig.update_layout(height=600)
    fig.update_traces(textinfo="label+value")
    
    st.plotly_chart(fig, use_container_width=True)
    
    # Estat√≠sticas do treemap
    col1, col2, col3 = st.columns(3)
    
    total_potential = treemap_df['Value'].sum()
    largest_category = treemap_df.groupby('Category')['Value'].sum().idxmax()
    largest_residue = treemap_df.loc[treemap_df['Value'].idxmax(), 'Residue']
    
    with col1:
        st.metric(
            "üéØ Total Geral",
            f"{total_potential / 1_000_000:.1f}M Nm¬≥/ano",
            help="Soma de todos os res√≠duos"
        )
    
    with col2:
        category_total = treemap_df[treemap_df['Category'] == largest_category]['Value'].sum()
        st.metric(
            f"üèÜ Categoria L√≠der",
            largest_category,
            delta=f"{(category_total / total_potential * 100):.1f}% do total",
            help="Categoria com maior potencial total"
        )
    
    with col3:
        residue_value = treemap_df[treemap_df['Residue'] == largest_residue]['Value'].iloc[0]
        st.metric(
            f"ü•á Res√≠duo L√≠der",
            largest_residue,
            delta=f"{(residue_value / total_potential * 100):.1f}% do total",
            help="Res√≠duo individual com maior potencial"
        )

def render_residue_sunburst(df: pd.DataFrame) -> None:
    """Renderiza gr√°fico sunburst mostrando hierarquia categoria > res√≠duo > munic√≠pios"""
    
    st.subheader("‚òÄÔ∏è An√°lise Sunburst: Categoria ‚Üí Res√≠duo ‚Üí Top Munic√≠pios")
    
    if df.empty:
        st.warning("Nenhum dado dispon√≠vel")
        return
    
    # Controles
    col1, col2 = st.columns([2, 1])
    
    with col1:
        selected_category = st.selectbox(
            "Categoria para An√°lise Detalhada:",
            ["Agr√≠cola", "Pecu√°ria", "Urbano"],
            help="Foco na categoria selecionada"
        )
    
    with col2:
        top_n_municipalities = st.slider(
            "Top Munic√≠pios por Res√≠duo:",
            min_value=3,
            max_value=10,
            value=5,
            help="Quantos munic√≠pios mostrar por res√≠duo"
        )
    
    # Definir res√≠duos da categoria selecionada
    category_residues = {
        'Agr√≠cola': {
            'biogas_cana_nm_ano': 'üåæ Cana',
            'biogas_soja_nm_ano': 'üå± Soja', 
            'biogas_milho_nm_ano': 'üåΩ Milho',
            'biogas_cafe_nm_ano': '‚òï Caf√©',
            'biogas_citros_nm_ano': 'üçä Citros'
        },
        'Pecu√°ria': {
            'biogas_bovinos_nm_ano': 'üêÑ Bovinos',
            'biogas_suino_nm_ano': 'üê∑ Su√≠nos',
            'biogas_aves_nm_ano': 'üêî Aves',
            'biogas_piscicultura_nm_ano': 'üêü Piscicultura'
        },
        'Urbano': {
            'rsu_potencial_nm_habitante_ano': 'üóëÔ∏è RSU',
            'rpo_potencial_nm_habitante_ano': 'üåø RPO'
        }
    }
    
    residues = category_residues[selected_category]
    
    # Preparar dados para sunburst
    sunburst_data = []
    
    for residue_key, residue_label in residues.items():
        if residue_key in df.columns and df[residue_key].sum() > 0:
            # Top munic√≠pios para este res√≠duo
            top_municipalities = df[df[residue_key] > 0].nlargest(top_n_municipalities, residue_key)
            
            for _, municipality in top_municipalities.iterrows():
                sunburst_data.append({
                    'Category': selected_category,
                    'Residue': residue_label,
                    'Municipality': municipality['nm_mun'],
                    'Value': municipality[residue_key],
                    'ids': f"{selected_category}_{residue_label}_{municipality['nm_mun']}",
                    'parents': f"{selected_category}_{residue_label}"
                })
            
            # Total do res√≠duo
            sunburst_data.append({
                'Category': selected_category,
                'Residue': residue_label,
                'Municipality': '',
                'Value': df[residue_key].sum(),
                'ids': f"{selected_category}_{residue_label}",
                'parents': selected_category
            })
    
    # Total da categoria
    total_category_value = sum([df[key].sum() for key in residues.keys() if key in df.columns])
    sunburst_data.append({
        'Category': selected_category,
        'Residue': '',
        'Municipality': '',
        'Value': total_category_value,
        'ids': selected_category,
        'parents': ""
    })
    
    if not sunburst_data:
        st.warning(f"Nenhum dado encontrado para categoria {selected_category}")
        return
    
    sunburst_df = pd.DataFrame(sunburst_data)
    
    # Criar labels para o sunburst
    labels = []
    parents = []
    values = []
    
    # Categoria principal
    labels.append(selected_category)
    parents.append("")
    values.append(total_category_value)
    
    # Res√≠duos
    for residue_key, residue_label in residues.items():
        if residue_key in df.columns and df[residue_key].sum() > 0:
            labels.append(residue_label)
            parents.append(selected_category)
            values.append(df[residue_key].sum())
            
            # Top munic√≠pios
            top_municipalities = df[df[residue_key] > 0].nlargest(top_n_municipalities, residue_key)
            for _, municipality in top_municipalities.iterrows():
                labels.append(f"{municipality['nm_mun'][:15]}...") # Truncar nomes longos
                parents.append(residue_label)
                values.append(municipality[residue_key])
    
    # Criar gr√°fico sunburst
    fig = go.Figure(go.Sunburst(
        labels=labels,
        parents=parents,
        values=values,
        branchvalues="total",
        maxdepth=3,
        insidetextorientation='radial'
    ))
    
    fig.update_layout(
        title=f"An√°lise Hier√°rquica - {selected_category}",
        height=600,
        font_size=10
    )
    
    st.plotly_chart(fig, use_container_width=True)

def render_residue_radar_chart(df: pd.DataFrame) -> None:
    """Renderiza gr√°fico radar comparando perfil de res√≠duos por munic√≠pio"""
    
    st.subheader("üéØ Perfil Radar: Composi√ß√£o de Res√≠duos por Munic√≠pio")
    
    if df.empty:
        st.warning("Nenhum dado dispon√≠vel")
        return
    
    # Sele√ß√£o de munic√≠pios para compara√ß√£o
    col1, col2 = st.columns([2, 1])
    
    with col1:
        available_municipalities = df[df['total_final_nm_ano'] > 0].nlargest(50, 'total_final_nm_ano')
        municipality_options = {
            row['cd_mun']: f"{row['nm_mun']} ({row['total_final_nm_ano']:,.0f} Nm¬≥/ano)"
            for _, row in available_municipalities.iterrows()
        }
        
        selected_municipalities = st.multiselect(
            "Selecione Munic√≠pios para Compara√ß√£o:",
            list(municipality_options.keys()),
            default=list(municipality_options.keys())[:5],
            format_func=lambda x: municipality_options[x],
            help="M√°ximo recomendado: 5 munic√≠pios para melhor visualiza√ß√£o"
        )
    
    with col2:
        normalize_values = st.checkbox(
            "Normalizar Valores",
            value=True,
            help="Normaliza valores por munic√≠pio para compara√ß√£o de perfis"
        )
    
    if not selected_municipalities:
        st.info("Selecione pelo menos um munic√≠pio para an√°lise")
        return
    
    # Definir categorias de res√≠duos para radar
    residue_categories = {
        'üåæ Cana': 'biogas_cana_nm_ano',
        'üå± Soja': 'biogas_soja_nm_ano',
        'üåΩ Milho': 'biogas_milho_nm_ano',
        '‚òï Caf√©': 'biogas_cafe_nm_ano',
        'üçä Citros': 'biogas_citros_nm_ano',
        'üêÑ Bovinos': 'biogas_bovinos_nm_ano',
        'üê∑ Su√≠nos': 'biogas_suino_nm_ano',
        'üêî Aves': 'biogas_aves_nm_ano',
        'üêü Piscicultura': 'biogas_piscicultura_nm_ano'
    }
    
    # Filtrar dados dos munic√≠pios selecionados
    selected_data = df[df['cd_mun'].isin(selected_municipalities)].copy()
    
    # Criar gr√°fico radar
    fig = go.Figure()
    
    colors = px.colors.qualitative.Set1[:len(selected_municipalities)]
    
    for i, (_, municipality) in enumerate(selected_data.iterrows()):
        values = []
        categories = []
        
        for category_label, column_name in residue_categories.items():
            if column_name in df.columns:
                value = municipality.get(column_name, 0)
                
                if normalize_values and municipality['total_final_nm_ano'] > 0:
                    # Normalizar como percentual do total do munic√≠pio
                    value = (value / municipality['total_final_nm_ano']) * 100
                
                values.append(value)
                categories.append(category_label)
        
        # Fechar o radar (duplicar primeiro valor)
        values.append(values[0])
        categories.append(categories[0])
        
        fig.add_trace(go.Scatterpolar(
            r=values,
            theta=categories,
            fill='toself',
            name=municipality['nm_mun'],
            line_color=colors[i % len(colors)],
            opacity=0.7
        ))
    
    # Configurar layout do radar
    fig.update_layout(
        polar=dict(
            radialaxis=dict(
                visible=True,
                range=[0, max([max(values[:-1]) for trace in fig.data]) if fig.data else 100]
            )),
        title=f"Perfil de Res√≠duos - {'Normalizado' if normalize_values else 'Valores Absolutos'}",
        height=600,
        showlegend=True
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # An√°lise complementar
    if normalize_values:
        st.info("üîç **An√°lise Normalizada**: Os valores mostram a composi√ß√£o percentual de cada tipo de res√≠duo no potencial total de cada munic√≠pio.")
    else:
        st.info("üîç **Valores Absolutos**: Os valores mostram o potencial real em Nm¬≥/ano de cada tipo de res√≠duo.")

def render_residue_scatter_matrix(df: pd.DataFrame) -> None:
    """Renderiza matriz de dispers√£o para an√°lise de correla√ß√µes"""
    
    st.subheader("üîó Matriz de Dispers√£o: Correla√ß√µes entre Res√≠duos")
    
    if df.empty:
        st.warning("Nenhum dado dispon√≠vel")
        return
    
    # Selecionar res√≠duos para an√°lise
    available_residues = {
        'biogas_cana_nm_ano': 'üåæ Cana',
        'biogas_soja_nm_ano': 'üå± Soja',
        'biogas_milho_nm_ano': 'üåΩ Milho',
        'biogas_bovinos_nm_ano': 'üêÑ Bovinos',
        'biogas_suino_nm_ano': 'üê∑ Su√≠nos',
        'biogas_aves_nm_ano': 'üêî Aves'
    }
    
    # Filtrar apenas res√≠duos que existem no dataset
    valid_residues = {k: v for k, v in available_residues.items() if k in df.columns and df[k].sum() > 0}
    
    if len(valid_residues) < 2:
        st.warning("S√£o necess√°rios pelo menos 2 tipos de res√≠duos para an√°lise de correla√ß√£o")
        return
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        selected_residues = st.multiselect(
            "Selecione Res√≠duos para An√°lise:",
            list(valid_residues.keys()),
            default=list(valid_residues.keys())[:4],
            format_func=lambda x: valid_residues[x],
            help="M√°ximo recomendado: 4-5 res√≠duos para visualiza√ß√£o clara"
        )
    
    with col2:
        log_scale = st.checkbox(
            "Escala Logar√≠tmica",
            help="Usar escala log para melhor visualiza√ß√£o de dados com grandes varia√ß√µes"
        )
        
        show_correlation_values = st.checkbox(
            "Mostrar Valores de Correla√ß√£o",
            value=True,
            help="Exibir coeficientes de correla√ß√£o nos gr√°ficos"
        )
    
    if len(selected_residues) < 2:
        st.info("Selecione pelo menos 2 res√≠duos para an√°lise")
        return
    
    # Preparar dados
    scatter_data = df[selected_residues].copy()
    
    if log_scale:
        # Aplicar log scale (evitar log de zero)
        for col in scatter_data.columns:
            scatter_data[col] = np.log1p(scatter_data[col])  # log(1+x) para evitar log(0)
    
    # Renomear colunas para labels mais amig√°veis
    scatter_data.columns = [valid_residues[col] for col in scatter_data.columns]
    
    # Criar matriz de scatter plots
    fig = px.scatter_matrix(
        scatter_data,
        title=f"Matriz de Correla√ß√£o entre Res√≠duos{' (Escala Log)' if log_scale else ''}",
        height=600
    )
    
    fig.update_layout(
        font_size=10,
        title_x=0.5
    )
    
    # Configurar tamanho dos pontos
    fig.update_traces(marker=dict(size=3, opacity=0.6))
    
    st.plotly_chart(fig, use_container_width=True)
    
    # Mostrar matriz de correla√ß√£o num√©rica
    if show_correlation_values:
        st.subheader("üìä Coeficientes de Correla√ß√£o")
        
        correlation_matrix = scatter_data.corr()
        
        # Criar heatmap da correla√ß√£o
        fig_corr = px.imshow(
            correlation_matrix,
            text_auto='.2f',
            color_continuous_scale='RdBu_r',
            title="Matriz de Correla√ß√£o (Coeficientes de Pearson)",
            labels={'color': 'Correla√ß√£o'}
        )
        
        fig_corr.update_layout(height=400)
        
        st.plotly_chart(fig_corr, use_container_width=True)

def render_comparative_analysis_dashboard(df: pd.DataFrame) -> None:
    """Dashboard principal de an√°lises comparativas avan√ßadas"""
    
    st.header("üìä An√°lises Comparativas Avan√ßadas")
    st.markdown("---")
    
    if df.empty:
        st.error("‚ùå Nenhum dado dispon√≠vel para an√°lise comparativa")
        return
    
    # Layout em tabs para diferentes tipos de an√°lise
    tab1, tab2, tab3, tab4 = st.tabs([
        "üå≥ Treemap",
        "‚òÄÔ∏è Sunburst", 
        "üéØ Radar",
        "üîó Correla√ß√µes"
    ])
    
    with tab1:
        render_residue_treemap(df)
    
    with tab2:
        render_residue_sunburst(df)
    
    with tab3:
        render_residue_radar_chart(df)
    
    with tab4:
        render_residue_scatter_matrix(df)
    
    # Informa√ß√µes sobre as an√°lises
    st.markdown("---")
    with st.expander("‚ÑπÔ∏è Sobre as An√°lises Comparativas"):
        st.markdown("""
        **üå≥ Treemap**: Visualiza a propor√ß√£o hier√°rquica dos diferentes res√≠duos, facilitando a identifica√ß√£o dos tipos mais relevantes.
        
        **‚òÄÔ∏è Sunburst**: An√°lise em camadas mostrando categoria ‚Üí res√≠duo ‚Üí munic√≠pios top, ideal para entender a distribui√ß√£o detalhada.
        
        **üéØ Radar**: Compara o perfil de composi√ß√£o de res√≠duos entre diferentes munic√≠pios, √∫til para identificar especializa√ß√µes regionais.
        
        **üîó Correla√ß√µes**: Matriz de dispers√£o e correla√ß√£o para identificar rela√ß√µes entre diferentes tipos de res√≠duos.
        """)