"""
Dashboard de An√°lise Detalhada por Res√≠duos - CP2B
Sistema especializado para an√°lise comparativa de diferentes tipos de res√≠duos e potencial de biog√°s
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from typing import Dict, List, Optional, Any
import logging
from .comparative_charts import render_comparative_analysis_dashboard

logger = logging.getLogger(__name__)

class ResidueAnalyzer:
    """Analisador especializado para diferentes tipos de res√≠duos"""
    
    # Mapeamento detalhado dos res√≠duos
    RESIDUE_MAPPING = {
        'biogas_cana_nm_ano': {
            'label': 'Cana-de-a√ß√∫car',
            'category': 'Agr√≠cola',
            'icon': 'üåæ',
            'color': '#10b981',
            'description': 'Baga√ßo e palha da cana-de-a√ß√∫car',
            'unit': 'Nm¬≥/ano',
            'typical_range': (0, 50000)
        },
        'biogas_soja_nm_ano': {
            'label': 'Soja',
            'category': 'Agr√≠cola',
            'icon': 'üå±',
            'color': '#059669',
            'description': 'Res√≠duos da cultura da soja',
            'unit': 'Nm¬≥/ano',
            'typical_range': (0, 30000)
        },
        'biogas_milho_nm_ano': {
            'label': 'Milho',
            'category': 'Agr√≠cola',
            'icon': 'üåΩ',
            'color': '#fbbf24',
            'description': 'Sabugo, palha e restos da cultura do milho',
            'unit': 'Nm¬≥/ano',
            'typical_range': (0, 25000)
        },
        'biogas_cafe_nm_ano': {
            'label': 'Caf√©',
            'category': 'Agr√≠cola',
            'icon': '‚òï',
            'color': '#92400e',
            'description': 'Polpa, casca e mucilagem do caf√©',
            'unit': 'Nm¬≥/ano',
            'typical_range': (0, 15000)
        },
        'biogas_citros_nm_ano': {
            'label': 'Citros',
            'category': 'Agr√≠cola',
            'icon': 'üçä',
            'color': '#f59e0b',
            'description': 'Baga√ßo de laranja, lim√£o e outros c√≠tricos',
            'unit': 'Nm¬≥/ano',
            'typical_range': (0, 20000)
        },
        'biogas_bovinos_nm_ano': {
            'label': 'Bovinos',
            'category': 'Pecu√°ria',
            'icon': 'üêÑ',
            'color': '#dc2626',
            'description': 'Esterco e dejetos de bovinos',
            'unit': 'Nm¬≥/ano',
            'typical_range': (0, 100000)
        },
        'biogas_suino_nm_ano': {
            'label': 'Su√≠nos',
            'category': 'Pecu√°ria',
            'icon': 'üê∑',
            'color': '#be185d',
            'description': 'Dejetos de suinocultura',
            'unit': 'Nm¬≥/ano',
            'typical_range': (0, 80000)
        },
        'biogas_aves_nm_ano': {
            'label': 'Aves',
            'category': 'Pecu√°ria',
            'icon': 'üêî',
            'color': '#c2410c',
            'description': 'Cama de frango e dejetos av√≠colas',
            'unit': 'Nm¬≥/ano',
            'typical_range': (0, 60000)
        },
        'biogas_piscicultura_nm_ano': {
            'label': 'Piscicultura',
            'category': 'Pecu√°ria',
            'icon': 'üêü',
            'color': '#0ea5e9',
            'description': 'Res√≠duos da aquicultura e piscicultura',
            'unit': 'Nm¬≥/ano',
            'typical_range': (0, 15000)
        },
        'rsu_potencial_nm_habitante_ano': {
            'label': 'RSU (Res√≠duos S√≥lidos Urbanos)',
            'category': 'Urbano',
            'icon': 'üóëÔ∏è',
            'color': '#6366f1',
            'description': 'Lixo org√¢nico dom√©stico e comercial',
            'unit': 'Nm¬≥/hab/ano',
            'typical_range': (0, 50)
        },
        'rpo_potencial_nm_habitante_ano': {
            'label': 'RPO (Res√≠duos de Poda e Org√¢nicos)',
            'category': 'Urbano',
            'icon': 'üåø',
            'color': '#16a34a',
            'description': 'Res√≠duos de poda urbana e org√¢nicos',
            'unit': 'Nm¬≥/hab/ano',
            'typical_range': (0, 30)
        }
    }

def render_residue_overview_cards(df: pd.DataFrame) -> None:
    """Renderiza cards de vis√£o geral por categoria de res√≠duo"""
    
    st.subheader("üìä Vis√£o Geral por Categoria")
    
    if df.empty:
        st.warning("Nenhum dado dispon√≠vel para an√°lise")
        return
    
    # Calcular totais por categoria
    agricultural_total = sum([
        df.get('biogas_cana_nm_ano', 0).sum(),
        df.get('biogas_soja_nm_ano', 0).sum(),
        df.get('biogas_milho_nm_ano', 0).sum(),
        df.get('biogas_cafe_nm_ano', 0).sum(),
        df.get('biogas_citros_nm_ano', 0).sum()
    ])
    
    livestock_total = sum([
        df.get('biogas_bovinos_nm_ano', 0).sum(),
        df.get('biogas_suino_nm_ano', 0).sum(),
        df.get('biogas_aves_nm_ano', 0).sum(),
        df.get('biogas_piscicultura_nm_ano', 0).sum()
    ])
    
    urban_total = sum([
        df.get('rsu_potencial_nm_habitante_ano', 0).sum(),
        df.get('rpo_potencial_nm_habitante_ano', 0).sum()
    ])
    
    total_potential = agricultural_total + livestock_total + urban_total
    
    # Cards por categoria
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            "üåæ Setor Agr√≠cola",
            f"{agricultural_total / 1_000_000:.1f}M Nm¬≥/ano",
            delta=f"{(agricultural_total / total_potential * 100) if total_potential > 0 else 0:.1f}% do total",
            help="Total de biog√°s de todos os res√≠duos agr√≠colas"
        )
    
    with col2:
        st.metric(
            "üêÑ Setor Pecu√°rio",
            f"{livestock_total / 1_000_000:.1f}M Nm¬≥/ano",
            delta=f"{(livestock_total / total_potential * 100) if total_potential > 0 else 0:.1f}% do total",
            help="Total de biog√°s de todos os res√≠duos pecu√°rios"
        )
    
    with col3:
        st.metric(
            "üèôÔ∏è Setor Urbano",
            f"{urban_total / 1_000:.0f}k Nm¬≥/ano",
            delta=f"{(urban_total / total_potential * 100) if total_potential > 0 else 0:.1f}% do total",
            help="Total de biog√°s de res√≠duos urbanos (RSU + RPO)"
        )
    
    with col4:
        st.metric(
            "üéØ Potencial Total",
            f"{total_potential / 1_000_000:.1f}M Nm¬≥/ano",
            help="Soma de todos os res√≠duos analisados"
        )

def render_residue_comparison_chart(df: pd.DataFrame) -> None:
    """Renderiza gr√°fico de compara√ß√£o entre diferentes res√≠duos"""
    
    st.subheader("üî¨ Compara√ß√£o Detalhada por Tipo de Res√≠duo")
    
    if df.empty:
        st.warning("Nenhum dado dispon√≠vel")
        return
    
    # Preparar dados para visualiza√ß√£o
    residue_data = []
    analyzer = ResidueAnalyzer()
    
    for residue_key, residue_info in analyzer.RESIDUE_MAPPING.items():
        if residue_key in df.columns:
            total_potential = df[residue_key].sum()
            municipalities_with_potential = (df[residue_key] > 0).sum()
            avg_potential = df[df[residue_key] > 0][residue_key].mean() if municipalities_with_potential > 0 else 0
            max_potential = df[residue_key].max()
            
            residue_data.append({
                'residue': residue_info['label'],
                'category': residue_info['category'],
                'icon': residue_info['icon'],
                'color': residue_info['color'],
                'total_potential': total_potential,
                'municipalities_count': municipalities_with_potential,
                'avg_potential': avg_potential,
                'max_potential': max_potential,
                'unit': residue_info['unit']
            })
    
    if not residue_data:
        st.error("Nenhum dado de res√≠duos encontrado")
        return
    
    residue_df = pd.DataFrame(residue_data)
    
    # Controles de visualiza√ß√£o
    col1, col2 = st.columns([2, 1])
    
    with col1:
        chart_type = st.selectbox(
            "Tipo de An√°lise:",
            ["Potencial Total", "N√∫mero de Munic√≠pios", "Potencial M√©dio", "Potencial M√°ximo"],
            help="Escolha o aspecto a ser analisado"
        )
    
    with col2:
        show_category_colors = st.checkbox(
            "Cores por Categoria",
            value=True,
            help="Agrupar cores por categoria (Agr√≠cola, Pecu√°ria, Urbano)"
        )
    
    # Mapear tipo de an√°lise para coluna
    analysis_mapping = {
        "Potencial Total": "total_potential",
        "N√∫mero de Munic√≠pios": "municipalities_count", 
        "Potencial M√©dio": "avg_potential",
        "Potencial M√°ximo": "max_potential"
    }
    
    y_column = analysis_mapping[chart_type]
    
    # Criar gr√°fico
    if show_category_colors:
        # Definir cores por categoria
        category_colors = {
            'Agr√≠cola': '#10b981',
            'Pecu√°ria': '#dc2626', 
            'Urbano': '#6366f1'
        }
        
        fig = px.bar(
            residue_df,
            x='residue',
            y=y_column,
            color='category',
            color_discrete_map=category_colors,
            title=f"An√°lise por Res√≠duo: {chart_type}",
            labels={
                'residue': 'Tipo de Res√≠duo',
                y_column: chart_type,
                'category': 'Categoria'
            }
        )
    else:
        # Usar cores espec√≠ficas de cada res√≠duo
        fig = px.bar(
            residue_df,
            x='residue',
            y=y_column,
            color='residue',
            color_discrete_sequence=residue_df['color'].tolist(),
            title=f"An√°lise por Res√≠duo: {chart_type}"
        )
        
        # Remover legenda quando usar cores individuais
        fig.update_layout(showlegend=False)
    
    # Personalizar layout
    fig.update_layout(
        xaxis_title="Tipo de Res√≠duo",
        yaxis_title=chart_type,
        height=500,
        xaxis_tickangle=-45
    )
    
    # Adicionar anota√ß√µes com √≠cones (texto)
    for i, row in residue_df.iterrows():
        fig.add_annotation(
            x=row['residue'],
            y=row[y_column] + (row[y_column] * 0.05),  # 5% acima da barra
            text=row['icon'],
            showarrow=False,
            font=dict(size=20)
        )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # Tabela de detalhes
    with st.expander("üìã Detalhes Num√©ricos"):
        display_df = residue_df.copy()
        
        # Formatar valores
        display_df['total_potential'] = display_df['total_potential'].apply(lambda x: f"{x:,.0f}")
        display_df['avg_potential'] = display_df['avg_potential'].apply(lambda x: f"{x:,.0f}")
        display_df['max_potential'] = display_df['max_potential'].apply(lambda x: f"{x:,.0f}")
        
        # Renomear colunas
        display_df = display_df.rename(columns={
            'residue': 'Res√≠duo',
            'category': 'Categoria', 
            'total_potential': 'Potencial Total',
            'municipalities_count': 'Munic√≠pios',
            'avg_potential': 'M√©dia',
            'max_potential': 'M√°ximo'
        })
        
        st.dataframe(
            display_df[['Res√≠duo', 'Categoria', 'Potencial Total', 'Munic√≠pios', 'M√©dia', 'M√°ximo']],
            hide_index=True
        )

def render_geographical_residue_distribution(df: pd.DataFrame) -> None:
    """Renderiza an√°lise da distribui√ß√£o geogr√°fica por res√≠duo"""
    
    st.subheader("üó∫Ô∏è Distribui√ß√£o Geogr√°fica por Res√≠duo")
    
    if df.empty:
        st.warning("Nenhum dado dispon√≠vel")
        return
    
    analyzer = ResidueAnalyzer()
    
    # Sele√ß√£o de res√≠duo para an√°lise
    residue_options = {}
    for key, info in analyzer.RESIDUE_MAPPING.items():
        if key in df.columns and df[key].sum() > 0:
            residue_options[key] = f"{info['icon']} {info['label']}"
    
    if not residue_options:
        st.error("Nenhum res√≠duo com dados dispon√≠vel")
        return
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        selected_residue = st.selectbox(
            "Selecione o Res√≠duo para An√°lise:",
            list(residue_options.keys()),
            format_func=lambda x: residue_options[x],
            help="An√°lise geogr√°fica detalhada do res√≠duo selecionado"
        )
    
    with col2:
        show_top_n = st.slider(
            "Top Munic√≠pios:",
            min_value=5,
            max_value=50,
            value=15,
            help="N√∫mero de munic√≠pios com maior potencial"
        )
    
    if selected_residue:
        residue_info = analyzer.RESIDUE_MAPPING[selected_residue]
        
        # Filtrar e ordenar dados
        residue_data = df[df[selected_residue] > 0].copy()
        residue_data = residue_data.nlargest(show_top_n, selected_residue)
        
        if not residue_data.empty:
            # Gr√°fico de barras horizontais
            fig = go.Figure()
            
            fig.add_trace(go.Bar(
                y=residue_data['nm_mun'],
                x=residue_data[selected_residue],
                orientation='h',
                marker_color=residue_info['color'],
                text=residue_data[selected_residue].apply(lambda x: f"{x:,.0f}"),
                textposition='outside'
            ))
            
            fig.update_layout(
                title=f"{residue_info['icon']} Top {show_top_n} Munic√≠pios - {residue_info['label']}",
                xaxis_title=f"Potencial de Biog√°s ({residue_info['unit']})",
                yaxis_title="Munic√≠pios",
                height=max(400, show_top_n * 25),
                yaxis={'categoryorder': 'total ascending'}
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Estat√≠sticas do res√≠duo selecionado
            col1, col2, col3, col4 = st.columns(4)
            
            total_municipalities = len(df[df[selected_residue] > 0])
            total_potential = df[selected_residue].sum()
            avg_potential = df[df[selected_residue] > 0][selected_residue].mean()
            max_municipality = df.loc[df[selected_residue].idxmax()]
            
            with col1:
                st.metric(
                    "üèõÔ∏è Munic√≠pios",
                    f"{total_municipalities}",
                    help=f"Munic√≠pios com potencial de {residue_info['label']}"
                )
            
            with col2:
                st.metric(
                    "‚ö° Total",
                    f"{total_potential:,.0f}",
                    help=f"Potencial total em {residue_info['unit']}"
                )
            
            with col3:
                st.metric(
                    "üìä M√©dia",
                    f"{avg_potential:,.0f}",
                    help="Potencial m√©dio por munic√≠pio"
                )
            
            with col4:
                st.metric(
                    "ü•á L√≠der",
                    max_municipality['nm_mun'],
                    delta=f"{max_municipality[selected_residue]:,.0f}",
                    help="Munic√≠pio com maior potencial"
                )
        
        else:
            st.info(f"Nenhum munic√≠pio tem potencial significativo para {residue_info['label']}")

def render_residue_correlation_analysis(df: pd.DataFrame) -> None:
    """Renderiza an√°lise de correla√ß√£o entre diferentes res√≠duos"""
    
    st.subheader("üîó An√°lise de Correla√ß√£o entre Res√≠duos")
    
    if df.empty:
        st.warning("Nenhum dado dispon√≠vel")
        return
    
    analyzer = ResidueAnalyzer()
    
    # Preparar dados de correla√ß√£o
    residue_columns = []
    residue_labels = []
    
    for key, info in analyzer.RESIDUE_MAPPING.items():
        if key in df.columns and df[key].sum() > 0:
            residue_columns.append(key)
            residue_labels.append(info['label'])
    
    if len(residue_columns) < 2:
        st.warning("S√£o necess√°rios pelo menos 2 tipos de res√≠duos para an√°lise de correla√ß√£o")
        return
    
    # Calcular matriz de correla√ß√£o
    correlation_data = df[residue_columns].corr()
    
    # Renomear √≠ndices e colunas para labels leg√≠veis
    correlation_data.index = residue_labels
    correlation_data.columns = residue_labels
    
    # Gr√°fico de heatmap
    fig = px.imshow(
        correlation_data,
        text_auto='.2f',
        color_continuous_scale='RdBu_r',
        title="Matriz de Correla√ß√£o entre Tipos de Res√≠duos",
        labels={'color': 'Correla√ß√£o'}
    )
    
    fig.update_layout(
        height=500,
        xaxis_title="Tipos de Res√≠duos",
        yaxis_title="Tipos de Res√≠duos"
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # Interpreta√ß√£o das correla√ß√µes
    with st.expander("üìñ Como Interpretar"):
        st.markdown("""
        **Interpreta√ß√£o da Matriz de Correla√ß√£o:**
        
        - **Valores pr√≥ximos a +1.0**: Correla√ß√£o positiva forte (quando um aumenta, o outro tamb√©m)
        - **Valores pr√≥ximos a -1.0**: Correla√ß√£o negativa forte (quando um aumenta, o outro diminui)
        - **Valores pr√≥ximos a 0.0**: Sem correla√ß√£o significativa
        
        **Insights √öteis:**
        - Correla√ß√µes altas entre res√≠duos agr√≠colas podem indicar regi√µes especializadas
        - Correla√ß√µes entre pecu√°ria e agricultura podem mostrar sistemas integrados
        - Baixa correla√ß√£o urbano vs. rural √© esperada devido a diferentes caracter√≠sticas municipais
        """)
    
    # Top correla√ß√µes
    st.subheader("üîç Principais Correla√ß√µes")
    
    # Extrair correla√ß√µes (excluindo diagonal)
    correlations = []
    for i in range(len(correlation_data.index)):
        for j in range(i+1, len(correlation_data.columns)):
            correlations.append({
                'Res√≠duo 1': correlation_data.index[i],
                'Res√≠duo 2': correlation_data.columns[j],
                'Correla√ß√£o': correlation_data.iloc[i, j],
                'For√ßa': abs(correlation_data.iloc[i, j])
            })
    
    # Ordenar por for√ßa da correla√ß√£o
    correlations_df = pd.DataFrame(correlations)
    correlations_df = correlations_df.sort_values('For√ßa', ascending=False)
    
    # Mostrar top 10
    top_correlations = correlations_df.head(10).copy()
    top_correlations['Correla√ß√£o'] = top_correlations['Correla√ß√£o'].apply(lambda x: f"{x:.3f}")
    top_correlations = top_correlations.drop('For√ßa', axis=1)
    
    st.dataframe(top_correlations, hide_index=True)

def render_residue_analysis_dashboard(df: pd.DataFrame) -> None:
    """Dashboard principal de an√°lise de res√≠duos"""
    
    st.header("üî¨ An√°lise Detalhada por Res√≠duos")
    st.markdown("---")
    
    if df.empty:
        st.error("‚ùå Nenhum dado dispon√≠vel para an√°lise")
        st.info("Verifique os filtros aplicados ou carregue dados na aplica√ß√£o principal")
        return
    
    # Verificar se h√° dados de res√≠duos
    analyzer = ResidueAnalyzer()
    has_residue_data = any(
        col in df.columns and df[col].sum() > 0 
        for col in analyzer.RESIDUE_MAPPING.keys()
    )
    
    if not has_residue_data:
        st.warning("‚ö†Ô∏è Nenhum dado espec√≠fico de res√≠duos encontrado nos dados fornecidos")
        return
    
    # Layout em tabs para diferentes an√°lises
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "üìä Vis√£o Geral", 
        "üî¨ Compara√ß√£o Detalhada", 
        "üó∫Ô∏è Distribui√ß√£o Geogr√°fica",
        "üîó An√°lise de Correla√ß√£o",
        "üìà Visualiza√ß√µes Avan√ßadas"
    ])
    
    with tab1:
        render_residue_overview_cards(df)
        st.markdown("---")
        
        # Informa√ß√µes adicionais sobre os res√≠duos
        st.subheader("‚ÑπÔ∏è Informa√ß√µes sobre os Res√≠duos")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.markdown("""
            **üåæ Res√≠duos Agr√≠colas:**
            - Cana-de-a√ß√∫car: Baga√ßo e palha
            - Soja: Restos de cultura
            - Milho: Sabugo e palha
            - Caf√©: Polpa e casca
            - Citros: Baga√ßo de frutas
            """)
        
        with col2:
            st.markdown("""
            **üêÑ Res√≠duos Pecu√°rios:**
            - Bovinos: Esterco
            - Su√≠nos: Dejetos l√≠quidos
            - Aves: Cama de frango
            - Piscicultura: Res√≠duos aqu√≠colas
            """)
        
        with col3:
            st.markdown("""
            **üèôÔ∏è Res√≠duos Urbanos:**
            - RSU: Lixo org√¢nico dom√©stico
            - RPO: Poda urbana e org√¢nicos
            
            *Unidade diferente: Nm¬≥/hab/ano*
            """)
    
    with tab2:
        render_residue_comparison_chart(df)
    
    with tab3:
        render_geographical_residue_distribution(df)
    
    with tab4:
        render_residue_correlation_analysis(df)
    
    with tab5:
        render_comparative_analysis_dashboard(df)
    
    # Footer com informa√ß√µes t√©cnicas
    st.markdown("---")
    with st.expander("üîß Informa√ß√µes T√©cnicas"):
        st.markdown("""
        **Metodologia de An√°lise:**
        - Dados processados a partir do banco Excel original
        - C√°lculos baseados em fatores de convers√£o espec√≠ficos por res√≠duo
        - An√°lises estat√≠sticas descritivas e correlacionais
        
        **Limita√ß√µes:**
        - Dados dependem da qualidade das fontes municipais
        - Fatores de convers√£o podem variar regionalmente
        - An√°lise n√£o considera aspectos log√≠sticos e econ√¥micos
        """)